# -*- coding: utf-8 -*-
"""
/***************************************************************************
 DEMeditingDockWidget
                                 A QGIS plugin
 The plugin edits parts of DEM interactively
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-02-07
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Anastasia Igitova, Timofey Samsonov
        email                : nigitova2000@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal, QRectF
from qgis.core import QgsGeometry, QgsProject, QgsRectangle, Qgis, QgsLineString, QgsRaster, QgsFillSymbol, QgsMessageLog, QgsPoint, QgsFeatureRequest, QgsPointXY
from qgis.gui import QgsLayerTreeView, QgsMapToolEmitPoint, QgsMapToolIdentifyFeature, QgsMapTool, QgsRubberBand
import math
import processing
import numpy as np
import skimage
# import wradlib.ipol as ipol
# from WBT.whitebox_tools import WhiteboxTools
#from .DEMediting import applyValue

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'DEM_editing_dockwidget_base.ui'))


class DEMeditingDockWidget(QtWidgets.QDockWidget, FORM_CLASS):



    closingPlugin = pyqtSignal()


    def __init__(self, iface, parent=None):
        """Constructor."""
        super(DEMeditingDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        self.mode = None

        self.iface = iface

        self.profile_typeBox.addItems(['plain-straight', 'concave'])

        self.diff = 105
        self.diameter = 3
        self.buffer_dist_start = 3
        self.buffer_dist_end = 9
        self.std_dev_breach = 1
        self.std_dev_apply = 1
        self.reduce = 55
        self.buffer_move = 9
        self.click_count = 0
        self.coords = []

        self.valueSpinBox.valueChanged.connect(self.onValueChanged)
        self.Diameter.valueChanged.connect(self.onDiameterChanged)
        self.buffer_distance_start.valueChanged.connect(self.onBufferDistStartChanged)
        self.buffer_distance_end.valueChanged.connect(self.onBufferDistEndChanged)
        self.stad_dev_breach.valueChanged.connect(self.onStdDevBreachChanged)
        self.stad_dev_apply.valueChanged.connect(self.onStdDevApplyChanged)
        self.DiameterMove.valueChanged.connect(self.onBufferMoveChanged)
        self.Reduce.valueChanged.connect(self.onReduce)


        self.canvas = iface.mapCanvas()
        self.pointTool = QgsMapToolEmitPoint(self.canvas)
        self.canvas.setMapTool(self.pointTool)
        self.pointTool.canvasClicked.connect(self.canvasClickEvent)

        #click button

        self.edit_icon.clicked.connect(self.switchEditMode)
        self.fill_icon.clicked.connect(self.switchFillMode)
        self.breach_icon.clicked.connect(self.switchBreachMode)
        self.move_icon.clicked.connect(self.switchMoveMode)

        # self.iface.actionSelect().trigger()

    def switchEditMode(self):
        self.mode = 'edit' if self.mode == None else None

    def switchFillMode(self):
        self.mode = 'fill' if self.mode == None else None

        self.CreateMask()

    def switchMoveMode(self):
        self.mode = 'move' if self.mode == None else None

    def switchBreachMode(self):
        self.mode = 'breach' if self.mode == None else None

        self.selectFeature()

    def selectFeature(self):
        layer_dem = self.demBox_breach.currentLayer()

        layer_st = self.iface.activeLayer()

        self.iface.setActiveLayer(layer_st)
        self.iface.actionSelect()

        self.breachDipressions3(layer_dem, layer_st)

    def CreateMask(self):

        global layer_dem
        layer_dem = self.demBox_fill.currentLayer()
        global dem_provider
        dem_provider = layer_dem.dataProvider()
        path = dem_provider.dataSourceUri().split('.')[0]
        global layer_mask

        if self.createMask.isChecked():
            sinks = processing.run("wbt:Sink", {'dem':layer_dem,'zero_background':False,'output':path + '_sinks.tif'})
            vector_sinks = processing.run("wbt:RasterToVectorPolygons", {'input': sinks['output'] ,'output':path + '_vector_sinks.shp'})

            layer_mask = self.iface.addVectorLayer(vector_sinks['output'], 'Vector sinks', "ogr")
            symbol = QgsFillSymbol.createSimple({'color':'#289e26',
                                                'color_border':'#ff4000',
                                                'width_border':'1',
                                                'style':'no'})
            layer_mask.renderer().setSymbol(symbol)
            layer_mask.triggerRepaint()
            self.iface.layerTreeView().refreshLayerSymbology(layer_mask.id())

            if not layer_mask:
                self.iface.messageBar().pushMessage("Warning", "Layer failed to load!", level=Qgis.Warning)

        else:
            layer_mask = self.maskBox_fill.currentLayer()
            symbol = QgsFillSymbol.createSimple({'color': '#289e26',
                                                 'color_border': '#ff4000',
                                                 'width_border': '1',
                                                 'style': 'no'})
            layer_mask.renderer().setSymbol(symbol)
            layer_mask.triggerRepaint()
            self.iface.layerTreeView().refreshLayerSymbology(layer_mask.id())

        return

    def set_iface(self, iface):
        self.iface = iface

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    def canvasPress(self, point):
        self.x = point.x()
        self.y = point.y()

        if self.mode == 'move':
            self.coords.append(self.x)
            self.coords.append(self.y)

        return
    def canvasRelease(self, point):
        self.x = point.x()
        self.y = point.y()

        if self.mode == 'move':
            self.coords.append(self.x)
            self.coords.append(self.y)
            self.Move(self.coords[0], self.coords[1], self.coords[2], self.coords[3])

        self.coords = []
        return

    def canvasClickEvent(self, point):

        self.x = point.x()
        self.y = point.y()
        r = QgsRubberBand(self.canvas, False)

        if self.mode == 'edit':
            self.applyValue()

        if self.mode == 'fill':
            global layer_dem
            global dem_provider
            global layer_mask
            self.fillDepresions(layer_dem, dem_provider, layer_mask)

        if self.mode == 'move':
            self.coords.append(self.x)
            self.coords.append(self.y)
            self.click_count += 1
            if self.click_count == 2:
                self.Move(self.coords[0], self.coords[1], self.coords[2], self.coords[3])
                self.coords = []
                self.click_count = 0

        return

    def onValueChanged(self, new_val):
        self.diff = new_val
        return

    def onBufferMoveChanged(self, newDiameterMove):
        self.buffer_move = newDiameterMove
        return

    def onStdDevBreachChanged(self, newStDevB):
        self.std_dev_breach = newStDevB
        return

    def onStdDevApplyChanged(self, newStDevA):
        self.std_dev_apply = newStDevA
        return

    def onDiameterChanged(self, newDiameter):
        self.diameter = newDiameter
        return

    def onBufferDistStartChanged(self, newBufferDistStart):
        self.buffer_dist_start = newBufferDistStart
        return

    def onBufferDistEndChanged(self, newBufferDistEnd):
        self.buffer_dist_end = newBufferDistEnd
        return

    def onReduce(self, newReduce):
        self.reduce = newReduce

    def applyValue(self):

        layer = self.iface.activeLayer()
        provider = layer.dataProvider()
        pixsize = layer.rasterUnitsPerPixelX()
        raster_cols = layer.width()
        raster_rows = layer.height()
        layer_extent = provider.extent()
        min_x = layer_extent.xMinimum()
        min_y = layer_extent.yMinimum()
        max_x = layer_extent.xMaximum()
        max_y = layer_extent.yMaximum()

        # get index
        row = math.ceil((self.y - min_y) / pixsize)
        col = math.ceil((self.x - min_x) / pixsize)

        pixel_x_max = min_x + col * pixsize
        pixel_x_min = min_x + (col - 1) * pixsize
        pixel_y_max = min_y + row * pixsize
        pixel_y_min = min_y + (row - 1) * pixsize

        if self.diameter % 2 == 0:
            self.diameter += 1

        center_y = center_x = math.floor(self.diameter / 2)

        block_x_max = pixel_x_max + center_x * pixsize
        block_x_min = pixel_x_min - center_x * pixsize
        block_y_max = pixel_y_max + center_y * pixsize
        block_y_min = pixel_y_min - center_y * pixsize

        width_block = self.diameter
        height_block = self.diameter

        if (block_x_max > max_x) or (block_x_min < min_x) or (block_y_max > max_y) or (block_y_min < min_y):
            if block_x_max > max_x:
                block_x_max = max_x
                width_block = int(round((block_x_max - block_x_min) / pixsize))
            if block_x_min < min_x:
                block_x_min = min_x
                width_block = int(round((block_x_max - block_x_min) / pixsize))
                center_x = center_x - (self.diameter - width_block)
            if block_y_max > max_y:
                block_y_max = max_y
                height_block = int(round((block_y_max - block_y_min) / pixsize))
                center_y = center_y - (self.diameter - height_block)
            if block_y_min < min_y:
                block_y_min = min_y
                height_block = int(round((block_y_max - block_y_min) / pixsize))

        block_box = QgsRectangle(block_x_min, block_y_min, block_x_max, block_y_max)
        provider.setEditable(True)
        block = provider.block(1, block_box, width_block, height_block)

        # p = QgsPointXY(x, y)
        # val = provider.identify(p, QgsRaster.IdentifyFormatValue)
        # old_val_1 = val.results()[1]

        # d = self.std_dev_apply
        # if (self.diameter / d) < 6:
        d = self.diameter / 6

        for i in range(height_block):
            for j in range(width_block):

                old_val = block.value(i, j)

                gauss_center = (1 / (d * math.sqrt(2 * math.pi)))

                if ((i - center_y) ** 2 + (j - center_x) ** 2) <= math.floor(self.diameter / 2) ** 2:

                    dist = math.sqrt((i - center_y) ** 2 + (j - center_x) ** 2)
                    # d = self.std_dev_apply

                    gauss_local = (1 / (d * math.sqrt(2 * math.pi))) * math.e ** (- 0.5 * (dist / d) ** 2)
                    new_value = gauss_local / gauss_center * self.diff + old_val

                    block.setValue(i, j, new_value)

        block_up_row = row + center_y
        if block_up_row > raster_rows:
            block_up_row = raster_rows

        block_left_col = col - center_x
        if block_left_col < 0:
            block_left_col = 0

        offset_row = raster_rows - block_up_row
        offset_col = block_left_col - 1

        provider.writeBlock(block, 1, offset_col, offset_row)
        layer.triggerRepaint()
        self.iface.mapCanvas().refresh()
        provider.setEditable(False)


    def fillDepresions(self, layer_dem, dem_provider, layer_mask):

        mask_provider = layer_mask.dataProvider()
        dem_provider.setEditable(True)
        pixsize = layer_dem.rasterUnitsPerPixelX()

        click_point = QgsPointXY(self.x, self.y)
        polygons = layer_mask.getFeatures()
        poly_id = -1
        poly = 0

        for polygon in polygons:
            if polygon.geometry().contains(click_point) is True:
                poly_id = polygon.id()
                poly = polygon
                break

        if poly == 0:
            self.iface.messageBar().pushMessage("Warning", "There is no depression in the spot. Try again.",
                                                level=Qgis.Warning)

        buffer = poly.geometry().buffer(pixsize, 5, 3, 2, 2)

        block_box_buf = buffer.boundingBox()
        width_block_buf = round(block_box_buf.width() / pixsize)
        height_block_buf = round(block_box_buf.height() / pixsize)
        x_min_buf = block_box_buf.xMinimum()
        y_max_buf = block_box_buf.yMaximum()
        block_buf = dem_provider.block(1, block_box_buf, width_block_buf, height_block_buf)

        min_value = 1000000000000

        for i in range(height_block_buf):
            for j in range(width_block_buf):

                pixel_x = x_min_buf + (j + 0.5) * pixsize
                pixel_y = y_max_buf - (i + 0.5) * pixsize

                point = QgsPointXY(pixel_x, pixel_y)

                if buffer.contains(point) is True and poly.geometry().contains(point) is False:

                    if block_buf.value(i, j) < min_value:
                        min_value = block_buf.value(i, j)

        # QgsMessageLog.logMessage('min val {}'.format(min_value))
        offset_col = 0
        offset_row = 0

        for i in range(height_block_buf):
            for j in range(width_block_buf):

                pixel_x = x_min_buf + (j + 0.5) * pixsize
                pixel_y = y_max_buf - (i + 0.5) * pixsize
                if i == 0 and j == 0:
                    block_up_row = math.ceil((pixel_y - dem_provider.extent().yMinimum()) / pixsize)
                    block_left_col = math.ceil((pixel_x - dem_provider.extent().xMinimum()) / pixsize)
                    raster_rows = layer_dem.height()
                    offset_row = raster_rows - block_up_row
                    offset_col = block_left_col - 1
                point = QgsPointXY(pixel_x, pixel_y)

                if poly.geometry().contains(point) is True:
                    block_buf.setValue(i, j, min_value)

        dem_provider.writeBlock(block_buf, 1, offset_col, offset_row)
        mask_provider.deleteFeatures([poly_id])

        layer_dem.triggerRepaint()
        self.iface.mapCanvas().refresh()
        dem_provider.setEditable(False)


    def draw_line_byX(self, x0, y0, x1, y1):
        dx = x1 - x0
        dy = y1 - y0
        QgsMessageLog.logMessage('x0 {}, x1 {}, y0 {}, y1 {}'.format(x0, x1, y0, y1))
        try:
            d = dy / dx
        except:
            self.iface.messageBar().pushMessage("Warning", "Each pixel must contain only one vertice of the line. Try again.",
                                                level=Qgis.Warning)
        y = y0
        e = 0

        x_coord = []
        y_coord = []

        for x in range(x0, x1 + 1):
            # img[0, y, x] = 1
            e += abs(d)
            x_coord.append(x)
            y_coord.append(y)
            if e >= 0.5:
                y += int(math.copysign(1, dy))
                e -= 1
        return x_coord, y_coord

    def draw_line_byY(self, x0, y0, x1, y1):
        dx = x1 - x0
        dy = y1 - y0
        try:
            d = dx / dy
        except:
            self.iface.messageBar().pushMessage("Warning",
                                                "Each pixel must contain only one vertice of the line. Try again.",
                                                level=Qgis.Warning)

        x = x0
        e = 0

        x_coord = []
        y_coord = []

        for y in range(y0, y1 + 1):
            # img[0, y, x] = 1
            e += abs(d)
            x_coord.append(x)
            y_coord.append(y)
            if e >= 0.5:
                x += int(math.copysign(1, dx))
                e -= 1
        return x_coord, y_coord

    def draw_line(self, x0, y0, x1, y1):
        if abs(y1 - y0) <= abs(x1 - x0):
            if x0 > x1:
                x_coord, y_coord = self.draw_line_byX(x1, y1, x0, y0)
                x_coord = list(reversed(x_coord))
                y_coord = list(reversed(y_coord))
            else:
                x_coord, y_coord = self.draw_line_byX(x0, y0, x1, y1)
        else:
            if y0 > y1:
                x_coord, y_coord = self.draw_line_byY(x1, y1, x0, y0)
                x_coord = list(reversed(x_coord))
                y_coord = list(reversed(y_coord))
            else:
                x_coord, y_coord = self.draw_line_byY(x0, y0, x1, y1)

        return x_coord[:-1], y_coord[:-1]

    def profileFunction(self, diff, n, j, max_h, min_h):

        if str(self.profile_typeBox.currentText()) == 'plain-straight':
            new_val = - diff/(n - 1) * j + max_h
        else:
            F = -math.log(max_h/min_h) / n
            new_val = min_h * np.exp(-F * (n - j))

        return new_val

    def simple_idw(self, x, y, z, xi, yi):
        dist = self.distance_matrix(x, y, xi, yi)
        # QgsMessageLog.logMessage('dist {}'.format(dist))

        # In IDW, weights are 1 / distance
        weights = 1 / dist

        # Make weights sum to one
        weights /= weights.sum(axis=0)

        # Multiply the weights for each interpolated point by all observed Z-values
        zi = np.dot(weights.T, z)
        return zi

    def distance_matrix(self, x0, y0, x1, y1):
        obs = np.vstack((x0, y0)).T
        interp = np.vstack((x1, y1)).T

        d0 = np.subtract.outer(obs[:, 0], interp[:, 0]).astype(int, copy=False)
        d1 = np.subtract.outer(obs[:, 1], interp[:, 1]).astype(int, copy=False)

        # QgsMessageLog.logMessage('d0 {}'.format(d0))
        # QgsMessageLog.logMessage('distance {}'.format(np.hypot(d0, d1)))

        return np.hypot(d0, d1) ** 2

    # def breachDipressions(self, layer_dem, layer_st):
    #
    #     st_provider = layer_st.dataProvider()
    #     dem_provider = layer_dem.dataProvider()
    #     dem_provider.setEditable(True)
    #     pixsize = layer_dem.rasterUnitsPerPixelX()
    #
    #
    #     path = dem_provider.dataSourceUri().split('.')[0]
    #     path_st = st_provider.dataSourceUri()
    #
    #     fill = processing.run("wbt:FillDepressions", {'dem':layer_dem,'fix_flats':True,'flat_increment':None,'max_depth':None,'output':path + '_fill.tif'})
    #     accumulation = processing.run("wbt:D8FlowAccumulation", {'input':fill['output'],'out_type':0,'log':False,'clip':False,'pntr':False,'esri_pntr':False, 'output':path + '_acc.tif'})
    #     acc_layer = QgsRasterLayer(accumulation['output'], "acc")
    #     acc_provider = acc_layer.dataProvider()
    #
    #     selected_features = layer_st.selectedFeatures()
    #     selected_features_ids = [feature.id() for feature in selected_features]
    #
    #     for feature_id in selected_features_ids:
    #         layer_st.removeSelection()
    #         layer_st.select(feature_id)
    #
    #         raster_stream = processing.run("wbt:RasterizeStreams",
    #                                        {'streams': QgsProcessingFeatureSourceDefinition(path_st, True),
    #                                         'base': layer_dem, 'nodata': True, 'feature_id': False,
    #                                         'output': path + '_raster_stream.tif'})
    #         points = processing.run("native:pixelstopoints",
    #                                 {'INPUT_RASTER': raster_stream['output'], 'RASTER_BAND': 1, 'FIELD_NAME': 'VALUE',
    #                                  'OUTPUT': path + '_points.shp'})
    #
    #         #block box params
    #         envelope = processing.run("qgis:minimumboundinggeometry", {'INPUT':points['OUTPUT'],'FIELD':'','TYPE':0,'OUTPUT':'memory:'})
    #         bbox = [feature.geometry().buffer(pixsize/2, 5, 3, 2, 2) for feature in envelope['OUTPUT'].getFeatures()][0].boundingBox()
    #         width_block = round(bbox.width() / pixsize)
    #         height_block = round(bbox.height() / pixsize)
    #         box_x_min = bbox.xMinimum()
    #         box_y_max = bbox.yMaximum()
    #         block = dem_provider.block(1, bbox, width_block, height_block)
    #
    #         # create GeoDataFrame with points of a line
    #         points = gpd.read_file(points['OUTPUT'])
    #         crs = points.crs
    #
    #         table = gpd.GeoDataFrame(columns=['geometry','acc', 'elev', 'new_val', 'diff', 'buf_rad', 'i', 'j', 'i_buf', 'j_buf'], geometry='geometry')
    #         table.set_crs(crs)
    #
    #         table['geometry'] = points['geometry']
    #         n = table.shape[0]
    #
    #         # add accumulation and elevation
    #         for m in range(n):
    #             x = table['geometry'].iloc[m].x
    #             y = table['geometry'].iloc[m].y
    #             p = QgsPointXY(x, y)
    #
    #             elev_val = dem_provider.identify(p, QgsRaster.IdentifyFormatValue).results()[1]
    #             acc_val = acc_provider.identify(p, QgsRaster.IdentifyFormatValue).results()[1]
    #
    #             i = math.ceil((box_y_max - y) / pixsize)
    #             j = math.ceil((x - box_x_min) / pixsize)
    #
    #             table.at[m, 'acc'] = acc_val
    #             table.at[m, 'elev'] = elev_val
    #             table.at[m, 'i'] = i - 1
    #             table.at[m, 'j'] = j - 1
    #
    #         #sort from first point to last
    #         table.sort_values(['acc'], ascending=[True], inplace=True)
    #
    #
    #         # get difference between start point and end point
    #         max_h = table['elev'].iloc[0]
    #         min_h = table['elev'].iloc[-1]
    #         QgsMessageLog.logMessage('max {}, min {}'.format(max_h, min_h))
    #         diff = max_h - min_h
    #         # QgsMessageLog.logMessage('max {}, min {}'.format(max_h, min_h))
    #         table.reset_index(drop=True, inplace=True)
    #         new_vals = []
    #         diff_elevs = []
    #
    #         #calculate new value
    #         for j in range(n):
    #             new_val = self.profileFunction(diff, n, j, max_h)
    #             diff_elev = table['new_val'].iloc[j] - table['elev'].iloc[j]
    #             # QgsMessageLog.logMessage('new {}'.format(new_val))
    #             new_vals.append(new_val)
    #             diff_elevs.append(diff_elev)
    #
    #         table['new_val'] = pd.Series(new_vals)
    #         table['diff'] = pd.Series(diff_elevs)
    #
    #         table.sort_values(['i', 'j'], ascending=[True, True], inplace=True)
    #
    #         #set new value
    #         a = 0
    #
    #         for i in range(height_block):
    #             for j in range(width_block):
    #                 if a <= n-1 :
    #
    #                     if table['i'].iloc[a] == i and table['j'].iloc[a] == j:
    #
    #                         new_value = table['new_val'].iloc[a]
    #                         block.setValue(i, j, new_value)
    #                         a += 1
    #
    #                 else:
    #                     break
    #
    #         # write block
    #         block_up_row = round((dem_provider.extent().yMaximum() - bbox.yMaximum()) / pixsize)
    #         block_left_col = round((bbox.xMinimum() - dem_provider.extent().xMinimum()) / pixsize)
    #
    #         offset_row = block_up_row
    #         offset_col = block_left_col
    #
    #         dem_provider.writeBlock(block, 1, offset_col, offset_row)
    #
    #
    #         # if self.ordinary_buffer.isCheked():
    #         #             #     stream = layer_st.selectedFeatures()
    #         #             #     stream_buffer = stream.buffer((self.buffer_dist + 0.5) * pixsize, 5, 3, 2, 2)
    #         #             #
    #         #             #     #box for buffer
    #         #             #     bbox_buf = stream_buffer.boundingBox()
    #         #             #     width_block_buf = round(bbox_buf.width() / pixsize)
    #         #             #     height_block_buf = round(bbox_buf.height() / pixsize)
    #         #             #     box_x_min_buf = bbox_buf.xMinimum()
    #         #             #     box_y_max_buf = bbox_buf.yMaximum()
    #         #             #     block_buf = dem_provider.block(1, bbox_buf, width_block_buf, height_block_buf)
    #         #             #
    #         #             #     for i in range(height_block_buf):
    #         #             #         for j in range(width_block_buf):
    #         #             #
    #         #             #             pixel_x = box_x_min_buf + (j + 0.5) * pixsize
    #         #             #             pixel_y = box_y_max_buf - (i + 0.5) * pixsize
    #         #             #
    #         #             #             point = Point(pixel_x, pixel_y)
    #         #             #
    #         #             #             if stream_buffer.geometry.values[0].contains(point) is True:
    #         #             #                 nearest_point = shapely.ops.nearest_points(point, table.geometry.unary_union)[1]
    #         #             #                 d = self.buffer_dist / 6
    #         #             #                 dist = point.distance(nearest_point)
    #         #             #
    #         #             #                 new_value = (1 / (d * math.sqrt(2 * math.pi))) * math.e ** (- 0.5 * (dist / d) ** 2) * #self.diff + old_val
    #         #             #                 block_buf.setValue(i, j, new_value)
    #         if self.buffer.isChecked():
    #
    #             def simple_idw(x, y, z, xi, yi):
    #                 dist = distance_matrix(x, y, xi, yi)
    #                 # QgsMessageLog.logMessage('dist {}'.format(dist))
    #
    #                 # In IDW, weights are 1 / distance
    #                 weights = 1 / dist
    #
    #                 # Make weights sum to one
    #                 weights /= weights.sum(axis=0)
    #
    #                 # Multiply the weights for each interpolated point by all observed Z-values
    #                 zi = np.dot(weights.T, z)
    #                 return zi
    #
    #             def distance_matrix(x0, y0, x1, y1):
    #                 obs = np.vstack((x0, y0)).T
    #                 interp = np.vstack((x1, y1)).T
    #
    #                 d0 = np.subtract.outer(obs[:, 0], interp[:, 0]).astype(int, copy= False)
    #                 d1 = np.subtract.outer(obs[:, 1], interp[:, 1]).astype(int, copy= False)
    #
    #                 # QgsMessageLog.logMessage('d0 {}'.format(d0))
    #                 # QgsMessageLog.logMessage('distance {}'.format(np.hypot(d0, d1)))
    #
    #                 return np.hypot(d0, d1)
    #
    #             table.sort_values(['acc'], ascending=[True], inplace=True)
    #
    #             buf_values = []
    #             for l in range(self.buffer_dist_start, self.buffer_dist_end + 1, 2):
    #                 buf_values.append(l)
    #             QgsMessageLog.logMessage('buf_values {}'.format(buf_values))
    #
    #             len_buf_values = len(buf_values)
    #             QgsMessageLog.logMessage('len_buf_values {}'.format(len_buf_values))
    #
    #             for a in range(n):
    #
    #                 index = round(a * len_buf_values / n)
    #                 if index == 0:
    #                     index = 1
    #
    #                 index -= 1
    #                 QgsMessageLog.logMessage('a {}, n {}, index {}'.format(a, n, index))
    #                 table.at[a, 'buf_rad'] = buf_values[index]
    #
    #             x_min = []
    #             x_max = []
    #             y_min = []
    #             y_max = []
    #
    #             for b in range(n):
    #                 x = table['geometry'].iloc[b].x
    #                 y = table['geometry'].iloc[b].y
    #                 buf_rad_m = table['buf_rad'].iloc[b] / 2 * pixsize
    #
    #                 x_min.append(x - buf_rad_m)
    #                 x_max.append(x + buf_rad_m)
    #                 y_min.append(y - buf_rad_m)
    #                 y_max.append(y + buf_rad_m)
    #
    #             # QgsMessageLog.logMessage('x_max {}'.format(x_max))
    #             xmin = min(x_min)
    #             xmax = max(x_max)
    #             ymin = min(y_min)
    #             ymax = max(y_max)
    #             QgsMessageLog.logMessage('xmax {}, xmin {}, ymax {}, ymin {}'.format(xmax, xmin, ymax, ymin))
    #
    #             width_buf = round((xmax - xmin) / pixsize)
    #             height_buf = round((ymax - ymin) / pixsize)
    #             QgsMessageLog.logMessage('width {}, height {}'.format(width_buf, height_buf))
    #
    #             for c in range(n):
    #                 x = table['geometry'].iloc[c].x
    #                 y = table['geometry'].iloc[c].y
    #
    #                 i = math.ceil((ymax - y) / pixsize)
    #                 j = math.ceil((x - xmin) / pixsize)
    #
    #                 table.at[c, 'i_buf'] = i - 1
    #                 table.at[c, 'j_buf'] = j - 1
    #
    #             # create
    #             x_new = np.linspace(0, width_buf - 1, width_buf)
    #             y_new = np.linspace(0, height_buf - 1, height_buf)
    #
    #             x_grid, y_grid = np.meshgrid(x_new, y_new)
    #             x_grid, y_grid = x_grid.flatten(), y_grid.flatten()
    #
    #             idw = simple_idw(table['j_buf'], table['i_buf'], table['new_val'], x_grid, y_grid).reshape(height_buf, width_buf)
    #             QgsMessageLog.logMessage('table {}'.format(table))
    #             QgsMessageLog.logMessage('buf rad {}'.format(table[['buf_rad']]))
    #             # create mask array, weight array
    #             mask = np.zeros((height_buf, width_buf), dtype = int)
    #             count  = np.zeros((height_buf, width_buf), dtype = int)
    #             weight = np.zeros((height_buf, width_buf), dtype = float)
    #             line = np.ones((height_buf, width_buf), dtype = int)
    #
    #             xx = np.arange(mask.shape[0])
    #             yy = np.arange(mask.shape[1])
    #
    #             for pix in range(n):
    #                 # QgsMessageLog.logMessage('pix {}'.format(pix))
    #                 radius = math.floor(table['buf_rad'].iloc[pix] / 2)
    #                 circle = (xx[:,None] - table['i_buf'].iloc[pix]) ** 2 + (yy[None, :] - table['j_buf'].iloc[pix]) ** 2
    #                 inside = (circle <= (radius ** 2))
    #                 line[table['i_buf'].iloc[pix]][table['j_buf'].iloc[pix]] = 0
    #                 # mask = mask | inside
    #
    #                 count += inside
    #
    #                 dist = distance_matrix(table['j_buf'], table['i_buf'], x_grid, y_grid)[pix]
    #                 d = self.std_dev_breach
    #
    #                 gauss = (1 / (d * math.sqrt(2 * math.pi))) * math.e ** (- 0.5 * (dist / d) ** 2)
    #                 max_gauss = np.amax(gauss)
    #
    #                 normal_gaus = (gauss / max_gauss).reshape(height_buf, width_buf) * inside
    #
    #                 weight += normal_gaus
    #
    #             # line_count = weight / count
    #             # QgsMessageLog.logMessage('weight {}, count {}, line {}, weight / count {}'.format(weight, count, line, line_count))
    #             wf = (weight / count) * line
    #             w = 1 - wf
    #             QgsMessageLog.logMessage('wf {}'.format(wf))
    #             zfwf = idw * wf
    #             QgsMessageLog.logMessage('zfwf {}'.format(zfwf))
    #
    #             block_box = QgsRectangle(xmin, ymin, xmax, ymax)
    #             block_buf = dem_provider.block(1, block_box, width_buf, height_buf)
    #
    #             old_vals = np.zeros((height_buf, width_buf))
    #             for i in range(height_buf):
    #                 for j in range(width_buf):
    #                     old_vals[i, j] = block_buf.value(i, j)
    #
    #             # old_vals = np.array(old_vals).reshape(height_buf, width_buf)
    #
    #             QgsMessageLog.logMessage('old_vals {}'.format(old_vals))
    #
    #             sum = old_vals * w + zfwf
    #
    #             QgsMessageLog.logMessage('sum {}'.format(sum))
    #
    #             for i in range(height_buf):
    #                 for j in range(width_buf):
    #                     if sum[i, j] is not None:
    #                         # block_buf.setValue(i, j, sum[i, j])
    #                         if i == 0 or i == height_buf-1 or j == 0 or j == width_buf-1:
    #                             block_buf.setValue(i, j, 0)
    #                         else:
    #                             block_buf.setValue(i, j, 1000)
    #
    #             # for i in range(height_buf):
    #             #     for j in range(width_buf):
    #             #         val = block_buf.value(i, j)
    #             #         new_val_1 = val * w[i][j] + zfwf[i][j]
    #             #
    #             #         if zfwf[i][j] > 0 and wf[i][j] != 0: # добавить сравнение с самым маленьким значением высоты в блоке
    #             #             block_buf.setValue(i, j, new_val_1)
    #             #             QgsMessageLog.logMessage(
    #             #                 'i {}, j {}, val, {}, new {}, wf {}, zfwf {}'.format(i, j, val, new_val_1, wf[i][j], zfwf[i][j]))
    #
    #             block_up_row = round((dem_provider.extent().yMaximum() - ymax) / pixsize)
    #             block_left_col = round((xmin - dem_provider.extent().xMinimum()) / pixsize)
    #             QgsMessageLog.logMessage('block_up_row {}, block_left_col {}'.format(block_up_row, block_left_col))
    #
    #             offset_row = block_up_row
    #             offset_col = block_left_col + 1
    #             QgsMessageLog.logMessage('offset_row {}, offset_col {}'.format(offset_row, offset_col))
    #
    #             dem_provider.writeBlock(block_buf, 1, offset_col, offset_row)
    #
    #             # QgsMessageLog.logMessage('wf {}'.format(wf))
    #                 # QgsMessageLog.logMessage('norm gaussian {}'.format(normal_gaus))
    #
    #             # points = np.vstack((table[['j_buf']], table[['i_buf']])).transpose()
    #             #
    #             # x_new = np.linspace(0, width_buf - 1, width_buf)
    #             # y_new = np.linspace(0, height_buf - 1, height_buf)
    #             #
    #             # x_grid, y_grid = np.meshgrid(x_new, y_new)
    #             # trg = np.vstack((x_grid.ravel(), y_grid.ravel())).T
    #             #
    #             # idw = ipol.Idw(points, trg)
    #             # interpolated = idw(table[['new_val']]).reshape(width_buf, height_buf)
    #
    #
    #
    #             # QgsMessageLog.logMessage('z-new {}'.format(grid2))
    #             # QgsMessageLog.logMessage('mask {}'.format(mask))
    #
    #
    #         layer_st.removeSelection()
    #
    #     layer_dem.triggerRepaint()
    #     self.iface.mapCanvas().refresh()
    #     dem_provider.setEditable(False)
    #
    # def breachDipressions1(self, layer_dem, layer_st):
    #
    #     st_provider = layer_st.dataProvider()
    #     dem_provider = layer_dem.dataProvider()
    #     dem_provider.setEditable(True)
    #     pixsize = layer_dem.rasterUnitsPerPixelX()
    #
    #     path = dem_provider.dataSourceUri().split('.')[0]
    #     path_st = st_provider.dataSourceUri()
    #
    #     selected_features = layer_st.selectedFeatures()
    #
    #     for feature in selected_features:
    #         layer_st.removeSelection()
    #         if feature.geometry().isMultipart():
    #             lines = feature.geometry().asMultiPolyline()
    #
    #         else:
    #             lines = [feature.geometry().asPolyline()]
    #
    #         for line in lines:
    #             first_vert = line[0]
    #             last_vert = line[-1]
    #
    #             # QgsMessageLog.logMessage('x0 {}, y0 {}'.format(first_vert.x(), first_vert.y()))
    #             # QgsMessageLog.logMessage('x1 {}, y1 {}'.format(last_vert.x(), last_vert.y()))
    #
    #             buffer = line.geometry().buffer(pixsize/2, 5, 3, 2, 2)
    #             bbox = buffer.boundingBox()
    #             width_block = round(bbox.width() / pixsize)
    #             height_block = round(bbox.height() / pixsize)
    #             box_x_min = bbox.xMinimum()
    #             box_y_max = bbox.yMaximum()
    #
    #             block = dem_provider.block(1, bbox, width_block, height_block)
    #
    #             high = dem_provider.identify(first_vert, QgsRaster.IdentifyFormatValue).results()[1]
    #             low = dem_provider.identify(last_vert, QgsRaster.IdentifyFormatValue).results()[1]
    #             diff = high - low
    #
    #             # stream = np.zeros((2, height_block, width_block), dtype = int)
    #
    #             coords = []
    #
    #             for i in range(len(line) - 1):
    #                 x0 = math.floor((line[i].x() - box_x_min) / pixsize)
    #                 y0 = math.floor((box_y_max - line[i].y()) / pixsize)
    #
    #                 x1 = math.floor((line[i + 1].x() - box_x_min) / pixsize)
    #                 y1 = math.floor((box_y_max - line[i + 1].y()) / pixsize)
    #
    #                 coords.extend(self.draw_line(x0, y0, x1, y1))
    #
    #             coords = list(dict.fromkeys(coords))
    #
    #             n_pts = len(coords)
    #             new_value = np.arange(n_pts)
    #
    #             stream = np.arange(n_pts)
    #
    #             elev = self.profileFunction(diff, n_pts, stream, high)
    #
    #             for a in range(n_pts):
    #                 i = coords[a][0]
    #                 j = coords[a][1]
    #                 new_val = elev[a]
    #                 block.setValue(i, j, new_val)
    #
    #             # for i in range(height_block):
    #             #     for j in range(width_block):
    #             #         new_val = elev[i, j]
    #             #         if new_val != 0:
    #             #             block.setValue(i, j, new_val)
    #
    #             offset_row = round((dem_provider.extent().yMaximum() - box_y_max) / pixsize)
    #             offset_col = round((box_x_min - dem_provider.extent().xMinimum()) / pixsize)
    #
    #             dem_provider.writeBlock(block, 1, offset_col, offset_row)
    #
    #             # QgsMessageLog.logMessage('stream {}'.format(stream))
    #             layer_dem.triggerRepaint()
    #
    #             if self.buffer.isChecked():
    #
    #
    #
    #                 buf_values = []
    #                 QgsMessageLog.logMessage('self.buffer_dist_end {}'.format(self.buffer_dist_end))
    #
    #                 for l in range(self.buffer_dist_start, self.buffer_dist_end + 1, 2):
    #                     buf_values.append(l)
    #                 QgsMessageLog.logMessage('buf_values {}'.format(buf_values))
    #
    #                 len_buf_values = len(buf_values)
    #                 QgsMessageLog.logMessage('len_buf_values {}'.format(len_buf_values))
    #
    #                 buf_rad = []
    #                 for a in range(n_pts):
    #
    #                     index = round(a * len_buf_values / n_pts)
    #                     if index == 0:
    #                         index = 1
    #
    #                     index -= 1
    #                     # QgsMessageLog.logMessage('a {}, n {}, index {}'.format(a, n_pts, index))
    #                     buf_rad.append(buf_values[index])
    #
    #                 x_min = []
    #                 x_max = []
    #                 y_min = []
    #                 y_max = []
    #
    #                 x_coords = []
    #                 y_coords = []
    #
    #                 for b in range(n_pts):
    #                     x = coords[b][1]
    #                     x_coords.append(x)
    #                     y = coords[b][0]
    #                     y_coords.append(y)
    #                     buf_rad_m = math.floor(buf_rad[b] / 2)
    #                     QgsMessageLog.logMessage('buf_rad_m {}'.format(buf_rad_m))
    #
    #                     x_min.append(x - buf_rad_m)
    #                     x_max.append(x + buf_rad_m)
    #                     y_min.append(y - buf_rad_m)
    #                     y_max.append(y + buf_rad_m)
    #
    #                 x_old_coords = np.array(x_coords)
    #                 y_old_coords = np.array(y_coords)
    #
    #                 QgsMessageLog.logMessage('x_min {}, x_max {}, y_min {}, y_max {}'.format(min(x_min), max(x_max), min(y_min), max(y_max)))
    #                 QgsMessageLog.logMessage('box_x_min {}, box_y_max {}'.format(box_x_min, box_y_max))
    #
    #                 xmin = box_x_min + min(x_min) * pixsize
    #                 xmax = box_x_min + max(x_max) * pixsize
    #                 ymin = box_y_max - max(y_max) * pixsize
    #                 ymax = box_y_max - min(y_min) * pixsize
    #                 # QgsMessageLog.logMessage('xmin {}'.format(xmin))
    #
    #                 QgsMessageLog.logMessage('xmax {}, xmin {}, ymax {}, ymin {}'.format(xmax, xmin, ymax, ymin))
    #
    #                 width_buf = max(x_max) - min(x_min) + 1
    #                 height_buf = max(y_max) - min(y_min) + 1
    #                 QgsMessageLog.logMessage('width {}, height {}'.format(width_buf, height_buf))
    #
    #                 x_j_new_coords = x_old_coords - min(x_min)
    #                 y_i_new_coords = y_old_coords - min(y_min)
    #                 QgsMessageLog.logMessage('x_j_new_coords {}, y_i_new_coords {}'.format(x_j_new_coords, y_i_new_coords))
    #
    #                 # create
    #                 x_new = np.linspace(0, width_buf, width_buf)
    #                 y_new = np.linspace(0, height_buf, height_buf)
    #
    #                 x_grid, y_grid = np.meshgrid(x_new, y_new)
    #                 x_grid, y_grid = x_grid.flatten(), y_grid.flatten()
    #
    #                 idw = self.simple_idw(x_j_new_coords, y_i_new_coords, elev, x_grid, y_grid).reshape(height_buf, width_buf)
    #                 # QgsMessageLog.logMessage('table {}'.format(table))
    #                 # QgsMessageLog.logMessage('buf rad {}'.format(table[['buf_rad']]))
    #                 # create mask array, weight array
    #                 mask = np.zeros((height_buf, width_buf), dtype=int)
    #                 count = np.zeros((height_buf, width_buf), dtype=int)
    #                 weight = np.zeros((height_buf, width_buf), dtype=float)
    #                 line1 = np.ones((height_buf, width_buf), dtype=int)
    #
    #                 xx = np.arange(mask.shape[0])
    #                 yy = np.arange(mask.shape[1])
    #
    #                 for pix in range(n_pts):
    #                     # QgsMessageLog.logMessage('pix {}'.format(pix))
    #                     radius = math.floor(buf_rad[pix] / 2)
    #                     circle = (xx[:, None] - y_i_new_coords[pix]) ** 2 + (yy[None, :] - x_j_new_coords[pix]) ** 2
    #                     inside = (circle <= (radius ** 2))
    #                     line1[y_i_new_coords[pix]][x_j_new_coords[pix]] = 0
    #
    #                     # mask = mask | inside
    #
    #                     count += inside
    #
    #                     dist = self.distance_matrix(x_j_new_coords, y_i_new_coords, x_grid, y_grid)[pix]
    #                     d = self.std_dev_breach
    #
    #                     gauss = (1 / (d * math.sqrt(2 * math.pi))) * math.e ** (- 0.5 * (dist / d) ** 2)
    #                     max_gauss = np.amax(gauss)
    #
    #                     normal_gaus = (gauss / max_gauss).reshape(height_buf, width_buf) * inside
    #
    #                     weight += normal_gaus
    #
    #                 QgsMessageLog.logMessage('line1 {}'.format(line1))
    #
    #                 # line_count = weight / count
    #                 # QgsMessageLog.logMessage('weight {}, count {}, line {}, weight / count {}'.format(weight, count, line, line_count))
    #                 wf = (weight / count) * line1
    #                 w = 1 - wf
    #                 QgsMessageLog.logMessage('wf {}'.format(wf))
    #                 zfwf = idw * wf
    #                 QgsMessageLog.logMessage('zfwf {}'.format(zfwf))
    #
    #                 block_box = QgsRectangle(xmin, ymin, xmax, ymax)
    #                 block_buf = dem_provider.block(1, block_box, width_buf, height_buf)
    #
    #                 old_vals = np.zeros((height_buf, width_buf))
    #
    #                 for i in range(height_buf):
    #                     for j in range(width_buf):
    #                         old_vals[i, j] = block_buf.value(i, j)
    #                         block_buf.setValue(i, j, old_vals[i, j])
    #
    #                 # old_vals = np.array(old_vals).reshape(height_buf, width_buf)
    #
    #                 QgsMessageLog.logMessage('old_vals {}'.format(old_vals))
    #
    #                 sum = old_vals * w + zfwf
    #
    #                 QgsMessageLog.logMessage('sum {}'.format(sum))
    #
    #                 for i in range(height_buf):
    #                     for j in range(width_buf):
    #                         if sum[i, j] > -500 :
    #                             block_buf.setValue(i, j, sum[i, j])
    #                         # if i == 0 or i == height_buf - 1 or j == 0 or j == width_buf - 1:
    #                         #     block_buf.setValue(i, j, 0)
    #                         # else:
    #                         #     block_buf.setValue(i, j, 1000)
    #
    #                 # for i in range(height_buf):
    #                 #     for j in range(width_buf):
    #                 #         val = block_buf.value(i, j)
    #                 #         new_val_1 = val * w[i][j] + zfwf[i][j]
    #                 #
    #                 #         if zfwf[i][j] > 0 and wf[i][j] != 0: # добавить сравнение с самым маленьким значением высоты в блоке
    #                 #             block_buf.setValue(i, j, new_val_1)
    #                 #             QgsMessageLog.logMessage(
    #                 #                 'i {}, j {}, val, {}, new {}, wf {}, zfwf {}'.format(i, j, val, new_val_1, wf[i][j], zfwf[i][j]))
    #
    #                 offset_row = round((dem_provider.extent().yMaximum() - ymax) / pixsize)
    #                 offset_col = round((xmin - dem_provider.extent().xMinimum()) / pixsize)
    #                 # QgsMessageLog.logMessage('block_up_row {}, block_left_col {}'.format(block_up_row, block_left_col))
    #
    #                 QgsMessageLog.logMessage('offset_row {}, offset_col {}'.format(offset_row, offset_col))
    #
    #                 dem_provider.writeBlock(block_buf, 1, offset_col, offset_row)
    #
    #     layer_dem.triggerRepaint()
    #     self.iface.mapCanvas().refresh()
    #     dem_provider.setEditable(False)
    #
    # def breachDipressions2(self, layer_dem, layer_st):
    #
    #     st_provider = layer_st.dataProvider()
    #     dem_provider = layer_dem.dataProvider()
    #     dem_provider.setEditable(True)
    #     pixsize = layer_dem.rasterUnitsPerPixelX()
    #
    #     path = dem_provider.dataSourceUri().split('.')[0]
    #     path_st = st_provider.dataSourceUri()
    #
    #     selected_features = layer_st.selectedFeatures()
    #
    #     for feature in selected_features:
    #         layer_st.removeSelection()
    #         if feature.geometry().isMultipart():
    #             lines = feature.geometry().asMultiPolyline()
    #
    #         else:
    #             lines = [feature.geometry().asPolyline()]
    #
    #         for line in lines:
    #             first_vert = line[0]
    #             last_vert = line[-1]
    #
    #             buf_values = [l for l in range(self.buffer_dist_start, self.buffer_dist_end + 1, 2)]
    #             len_buf_values = len(buf_values)
    #
    #             if self.buffer.isChecked():
    #
    #                 # x_min = []
    #                 # x_max = []
    #                 # y_min = []
    #                 # y_max = []
    #                 #
    #                 # line_length = feature.geometry().length()
    #                 #
    #                 # segment_length = 0
    #                 #
    #                 # # points = [line[m] for m in range(len(line))]
    #                 #
    #                 # length_segments = [math.sqrt(line[i].sqrDist(line[j]))
    #                 #                    for i, j in itertools.combinations(range(len(line)), 2)
    #                 #                    if (j - i) == 1]
    #                 #
    #                 # for v in range(len(line)):
    #                 #     # QgsMessageLog.logMessage('x - 1{}, y - 1{}'.format(line[v - 1].x(), line[v - 1].y()))
    #                 #
    #                 #     index = round(segment_length * len_buf_values / line_length)
    #                 #     if index == 0:
    #                 #         index = 1
    #                 #
    #                 #     index -= 1
    #                 #     buf_rad = math.floor(buf_values[index] / 2)
    #                 #     # QgsMessageLog.logMessage('buf_rad {}'.format(buf_rad))
    #                 #     if v == 0:
    #                 #         segment_length = 0
    #                 #     else:
    #                 #         segment_length += length_segments[v - 1]
    #                 #
    #                 #     # buf_rad = math.floor(self.buffer_dist_end / 2)
    #                 #     # x = line[v].x()
    #                 #     # y = line[v].y()
    #                 #     x = 5
    #                 #     y = 5
    #                 #
    #                 #     x_min.append(x - buf_rad * pixsize)
    #                 #     x_max.append(x + buf_rad * pixsize)
    #                 #     y_min.append(y - buf_rad * pixsize)
    #                 #     y_max.append(y + buf_rad * pixsize)
    #                 #
    #                 #
    #                 # Xmin = min(x_min)
    #                 # Xmax = max(x_max)
    #                 # Ymin = min(y_min)
    #                 # Ymax = max(y_max)
    #                 #
    #                 # # QgsMessageLog.logMessage('x_min {}, x_max {}, y_min {}, y_max {}'.format(Xmin, Xmax, Ymin, Ymax))
    #
    #                 # bbox = QgsRectangle(Xmin, Ymin, Xmax, Ymax)
    #                 # width_block = round(Xmax - Xmin / pixsize) + 1
    #                 # height_block = round(Ymax - Ymin / pixsize)
    #                 # box_x_min = Xmin
    #                 # box_y_max = Ymax
    #
    #                 buffer = feature.geometry().buffer(pixsize / 2 + math.floor(max(self.buffer_dist_end,
    #                                                                                 self.buffer_dist_start) / 2) * pixsize, 5, 3, 2, 2)
    #                 bbox = buffer.boundingBox()
    #                 width_block = round(bbox.width() / pixsize)
    #                 height_block = round(bbox.height() / pixsize)
    #                 box_x_min = bbox.xMinimum()
    #                 box_y_max = bbox.yMaximum()
    #
    #                 block = dem_provider.block(1, bbox, width_block, height_block)
    #
    #             else:
    #
    #                 buffer = feature.geometry().buffer(pixsize / 2, 5, 3, 2, 2)
    #                 bbox = buffer.boundingBox()
    #                 width_block = round(bbox.width() / pixsize)
    #                 height_block = round(bbox.height() / pixsize)
    #                 box_x_min = bbox.xMinimum()
    #                 box_y_max = bbox.yMaximum()
    #
    #                 block = dem_provider.block(1, bbox, width_block, height_block)
    #
    #             high = dem_provider.identify(first_vert, QgsRaster.IdentifyFormatValue).results()[1] + self.reduce
    #             low = dem_provider.identify(last_vert, QgsRaster.IdentifyFormatValue).results()[1]
    #             diff = high - low
    #
    #             x_coords = []
    #             y_coords = []
    #             for i in range(len(line) - 1):
    #                 x0 = math.floor((line[i].x() - box_x_min) / pixsize)
    #                 y0 = math.floor((box_y_max - line[i].y()) / pixsize)
    #
    #                 x1 = math.floor((line[i + 1].x() - box_x_min) / pixsize)
    #                 y1 = math.floor((box_y_max - line[i + 1].y()) / pixsize)
    #
    #                 x, y = self.draw_line(x0, y0, x1, y1)
    #
    #                 x_coords.extend(x)
    #                 y_coords.extend(y)
    #
    #             # coords = list(dict.fromkeys(coords))
    #
    #             n_pts = len(x_coords)
    #             stream = np.arange(n_pts)
    #
    #             elev = self.profileFunction(diff, n_pts, stream, high)
    #
    #             buf_rad = []
    #
    #             for a in range(n_pts):
    #                 index = round(a * len_buf_values / n_pts)
    #                 if index == 0:
    #                     index = 1
    #
    #                 index -= 1
    #                 buf_rad.append(buf_values[index])
    #
    #                 i = y_coords[a]
    #                 j = x_coords[a]
    #                 new_val = elev[a]
    #                 block.setValue(i, j, new_val)
    #
    #             if self.buffer.isChecked():
    #                 x_new = np.linspace(0, width_block - 1, width_block)
    #                 y_new = np.linspace(0, height_block - 1, height_block)
    #
    #                 x_grid, y_grid = np.meshgrid(x_new, y_new)
    #                 x_grid, y_grid = x_grid.flatten(), y_grid.flatten()
    #
    #                 idw = self.simple_idw(x_coords, y_coords, elev, x_grid, y_grid).reshape(height_block,
    #                                                                                                     width_block)
    #                 # QgsMessageLog.logMessage('idw {}'.format(idw))
    #                 # QgsMessageLog.logMessage('buf rad {}'.format(table[['buf_rad']]))
    #                 # create mask array, weight array
    #                 mask = np.zeros((height_block, width_block), dtype=int)
    #                 count = np.zeros((height_block, width_block), dtype=int)
    #                 weight = np.zeros((height_block, width_block), dtype=float)
    #                 line1 = np.ones((height_block, width_block), dtype=int)
    #
    #                 xx = np.arange(mask.shape[0])
    #                 yy = np.arange(mask.shape[1])
    #                 QgsMessageLog.logMessage('height_block {}, width_block {}'.format(height_block, width_block))
    #
    #                 QgsMessageLog.logMessage('x_coords {}, y_coords {}'.format(x_coords, y_coords))
    #                 QgsMessageLog.logMessage('elev {}'.format(elev))
    #                 QgsMessageLog.logMessage('line1 {}'.format(line1))
    #
    #                 for pix in range(n_pts):
    #                     # QgsMessageLog.logMessage('pix {}'.format(pix))
    #                     radius = math.floor(buf_rad[pix] / 2)
    #                     circle = (xx[:, None] - y_coords[pix]) ** 2 + (yy[None, :] - x_coords[pix]) ** 2
    #                     inside = (circle <= (radius ** 2))
    #                     QgsMessageLog.logMessage('pix {}'.format(pix))
    #
    #                     line1[y_coords[pix]][x_coords[pix]] = 0
    #
    #                     # mask = mask | inside
    #
    #                     count += inside
    #
    #                     dist = self.distance_matrix(x_coords, y_coords, x_grid, y_grid)[pix]
    #                     d = self.std_dev_breach
    #
    #                     gauss = (1 / (d * math.sqrt(2 * math.pi))) * math.e ** (- 0.5 * (dist / d) ** 2)
    #                     max_gauss = np.amax(gauss)
    #
    #                     normal_gaus = (gauss / max_gauss).reshape(height_block, width_block) * inside
    #
    #                     weight += normal_gaus
    #
    #                 QgsMessageLog.logMessage('line1 {}'.format(line1))
    #
    #                 wf = (weight / count) * line1
    #                 w = 1 - wf
    #                 QgsMessageLog.logMessage('wf {}'.format(wf))
    #                 zfwf = idw * wf
    #                 QgsMessageLog.logMessage('zfwf {}'.format(zfwf))
    #
    #                 old_vals = np.zeros((height_block, width_block))
    #
    #                 for i in range(height_block):
    #                     for j in range(width_block):
    #                         old_vals[i, j] = block.value(i, j)
    #                         # block.setValue(i, j, old_vals[i, j])
    #
    #                 # old_vals = np.array(old_vals).reshape(height_buf, width_buf)
    #
    #                 QgsMessageLog.logMessage('old_vals {}'.format(old_vals))
    #
    #                 sum = old_vals * w + zfwf
    #
    #                 QgsMessageLog.logMessage('sum {}'.format(sum))
    #
    #                 for i in range(height_block):
    #                     for j in range(width_block):
    #                         if sum[i, j] > 0 and sum[i, j] < old_vals[i, j]:
    #                             block.setValue(i, j, sum[i, j])
    #                         else:
    #                             block.setValue(i, j, old_vals[i, j])
    #                         # if i == 0 or i == height_block - 1 or j == 0 or j == width_block - 1:
    #                         #     block.setValue(i, j, 0)
    #                         # else:
    #                         #     block.setValue(i, j, 1000)
    #
    #                 # for i in range(height_buf):
    #                 #     for j in range(width_buf):
    #                 #         val = block_buf.value(i, j)
    #                 #         new_val_1 = val * w[i][j] + zfwf[i][j]
    #                 #
    #                 #         if zfwf[i][j] > 0 and wf[i][j] != 0: # добавить сравнение с самым маленьким значением высоты в блоке
    #                 #             block_buf.setValue(i, j, new_val_1)
    #                 #             QgsMessageLog.logMessage(
    #                 #                 'i {}, j {}, val, {}, new {}, wf {}, zfwf {}'.format(i, j, val, new_val_1, wf[i][j], zfwf[i][j]))
    #
    #             offset_row = round((dem_provider.extent().yMaximum() - box_y_max) / pixsize)
    #             offset_col = round((box_x_min - dem_provider.extent().xMinimum()) / pixsize)
    #             # QgsMessageLog.logMessage('block_up_row {}, block_left_col {}'.format(block_up_row, block_left_col))
    #
    #             QgsMessageLog.logMessage('offset_row {}, offset_col {}'.format(offset_row, offset_col))
    #
    #             dem_provider.writeBlock(block, 1, offset_col, offset_row)
    #
    #             layer_dem.triggerRepaint()
    #             self.iface.mapCanvas().refresh()
    #             dem_provider.setEditable(False)

    def breachDipressions3(self, layer_dem, layer_st):

        st_provider = layer_st.dataProvider()
        dem_provider = layer_dem.dataProvider()
        dem_provider.setEditable(True)
        pixsize = layer_dem.rasterUnitsPerPixelX()

        min_x_dem = dem_provider.extent().xMinimum()
        min_y_dem = dem_provider.extent().yMinimum()
        max_y_dem = dem_provider.extent().yMaximum()

        selected_features = layer_st.selectedFeatures()

        for feature in selected_features:
            layer_st.removeSelection()
            layer_st.select(feature.id())
            if feature.geometry().isMultipart():
                lines = feature.geometry().asMultiPolyline()

            else:
                lines = [feature.geometry().asPolyline()]
            
            for line in lines:
                first_vert = line[0]
                last_vert = line[-1]

                buf_values = [l for l in range(self.buffer_dist_start, self.buffer_dist_end + 1, 2)]
                len_buf_values = len(buf_values)

                bbox = feature.geometry().boundingBox()
                x_min = bbox.xMinimum()
                x_max = bbox.xMaximum()
                y_min = bbox.yMinimum()
                y_max = bbox.yMaximum()

                new_x_min = math.floor((x_min - min_x_dem) / pixsize) * pixsize + min_x_dem
                new_x_max = math.ceil((x_max - min_x_dem) / pixsize) * pixsize + min_x_dem
                new_y_min = math.floor((y_min - min_y_dem) / pixsize) * pixsize + min_y_dem
                new_y_max = math.ceil((y_max - min_y_dem) / pixsize) * pixsize + min_y_dem

                bbox.setXMinimum(new_x_min)
                bbox.setXMaximum(new_x_max)
                bbox.setYMinimum(new_y_min)
                bbox.setYMaximum(new_y_max)

                if self.buffer.isChecked():

                    bbox = bbox.buffered(math.floor(max(self.buffer_dist_end, self.buffer_dist_start) / 2) * pixsize)

                    width_block = round(bbox.width() / pixsize)
                    height_block = round(bbox.height() / pixsize)

                    box_x_min = bbox.xMinimum()
                    box_y_max = bbox.yMaximum()

                    block = dem_provider.block(1, bbox, width_block, height_block)

                else:

                    width_block = round(bbox.width() / pixsize)
                    height_block = round(bbox.height() / pixsize)
                    box_x_min = bbox.xMinimum()
                    box_y_max = bbox.yMaximum()

                    block = dem_provider.block(1, bbox, width_block, height_block)


                # high = dem_provider.identify(first_vert, QgsRaster.IdentifyFormatValue).results()[1] - self.reduce
                high, res = dem_provider.sample(first_vert, 1)
                high -= self.reduce
                QgsMessageLog.logMessage('high {}'.format(high))
                low, res = dem_provider.sample(last_vert, 1)
                diff = high - low

                x_coords = []
                y_coords = []
                for i in range(len(line) - 1):
                    x0 = math.floor((line[i].x() - box_x_min) / pixsize)
                    y0 = math.floor((box_y_max - line[i].y()) / pixsize)

                    x1 = math.floor((line[i + 1].x() - box_x_min) / pixsize)
                    y1 = math.floor((box_y_max - line[i + 1].y()) / pixsize)

                    x, y = self.draw_line(x0, y0, x1, y1)

                    x_coords.extend(x)
                    y_coords.extend(y)
                    if i == len(line) - 2:
                        x_coords.append(x1)
                        y_coords.append(y1)


                n_pts = len(x_coords)
                stream = np.arange(n_pts)

                elev = self.profileFunction(diff, n_pts, stream, high, low)

                buf_rad = []
                stream1 = []

                for a in range(n_pts):
                    index = round(a * len_buf_values / n_pts)
                    if index == 0:
                        index = 1

                    index -= 1
                    buf_rad.append(buf_values[index])

                    i = y_coords[a]
                    j = x_coords[a]
                    new_val = elev[a]
                    stream1.append(block.value(i, j))
                    if self.buffer.isChecked() is False:
                        if new_val < block.value(i, j):
                            block.setValue(i, j, new_val)

                if self.buffer.isChecked():
                    x_new = np.arange(0, width_block)
                    y_new = np.arange(0, height_block)

                    x_grid, y_grid = np.meshgrid(x_new, y_new)
                    x_grid, y_grid = x_grid.flatten(), y_grid.flatten()

                    mask = np.zeros((height_block, width_block), dtype=int)
                    count = np.zeros((height_block, width_block), dtype=int)
                    weight = np.zeros((height_block, width_block), dtype=float)
                    line1 = np.ones((height_block, width_block), dtype=int)

                    xx = np.arange(mask.shape[0])
                    yy = np.arange(mask.shape[1])

                    for pix in range(n_pts):
                        radius = math.floor(buf_rad[pix] / 2)
                        circle = (xx[:, None] - y_coords[pix]) ** 2 + (yy[None, :] - x_coords[pix]) ** 2
                        inside = (circle <= (radius ** 2))

                        line1[y_coords[pix]][x_coords[pix]] = 0

                        count += inside

                        dist = self.distance_matrix(x_coords, y_coords, x_grid, y_grid)[pix]
                        d = self.std_dev_breach

                        gauss = (1 / (d * math.sqrt(2 * math.pi))) * math.e ** (- 0.5 * (dist / d) ** 2)
                        max_gauss = np.amax(gauss)

                        normal_gaus = (gauss / max_gauss).reshape(height_block, width_block) * inside * (stream1[pix] - elev[pix])

                        weight = np.where(normal_gaus > weight, normal_gaus, weight)
                        # weight += normal_gaus

                    old_vals = np.zeros((height_block, width_block))

                    for i in range(height_block):
                        for j in range(width_block):
                            old_vals[i, j] = block.value(i, j)

                    h = old_vals - weight

                    for i in range(height_block):
                        for j in range(width_block):
                            if h[i, j] > low: # h[i, j] < old_vals[i, j] and
                                block.setValue(i, j, h[i, j])
                            else:
                                block.setValue(i, j, old_vals[i, j])

                offset_row = round((max_y_dem - box_y_max) / pixsize)
                offset_col = round((box_x_min - min_x_dem) / pixsize)

                dem_provider.writeBlock(block, 1, offset_col, offset_row)

                layer_dem.triggerRepaint()
                self.iface.mapCanvas().refresh()
                dem_provider.setEditable(False)


    def Move(self, x0, y0, x1, y1):

        layer_dem = self.iface.activeLayer()
        dem_provider = layer_dem.dataProvider()
        dem_provider.setEditable(True)
        pixsize = layer_dem.rasterUnitsPerPixelX()

        min_x_dem = dem_provider.extent().xMinimum()
        min_y_dem = dem_provider.extent().yMinimum()
        max_y_dem = dem_provider.extent().yMaximum()

        vector = QgsLineString([x0, x1], [y0, y1])

        bbox = vector.boundingBox()
        x_min = bbox.xMinimum()
        x_max = bbox.xMaximum()
        y_min = bbox.yMinimum()
        y_max = bbox.yMaximum()

        new_x_min = math.floor((x_min - min_x_dem) / pixsize) * pixsize + min_x_dem
        new_x_max = math.ceil((x_max - min_x_dem) / pixsize) * pixsize + min_x_dem
        new_y_min = math.floor((y_min - min_y_dem) / pixsize) * pixsize + min_y_dem
        new_y_max = math.ceil((y_max - min_y_dem) / pixsize) * pixsize + min_y_dem

        bbox.setXMinimum(new_x_min)
        bbox.setXMaximum(new_x_max)
        bbox.setYMinimum(new_y_min)
        bbox.setYMaximum(new_y_max)

        bbox = bbox.buffered(math.floor(self.buffer_move / 2) * pixsize)

        width_block = round(bbox.width() / pixsize)
        height_block = round(bbox.height() / pixsize)

        box_x_min = bbox.xMinimum()
        box_y_max = bbox.yMaximum()
        box_y_min = bbox.yMinimum()

        block = dem_provider.block(1, bbox, width_block, height_block)

        box_x0 = math.floor((x0 - box_x_min) / pixsize)
        box_y0 = math.floor((y0 - box_y_min) / pixsize)
        box_x1 = math.floor((x1 - box_x_min) / pixsize)
        box_y1 = math.floor((y1 - box_y_min) / pixsize)

        x_coords, y_coords1 = self.draw_line(box_x0, box_y0, box_x1, box_y1)
        x_coords.append(box_x1)
        y_coords1.append(box_y1)
        y_coords = [height_block - y - 1 for y in y_coords1]

        n_pts = len(x_coords)

        mask = np.zeros((height_block, width_block), dtype=int)
        mask1 = np.zeros((height_block, width_block), dtype=int)

        xx = np.arange(mask.shape[0])
        yy = np.arange(mask.shape[1])

        for i in range(n_pts):
            radius = math.floor(self.buffer_move / 2)
            circle = (xx[:, None] - y_coords[i]) ** 2 + (yy[None, :] - x_coords[i]) ** 2
            inside = (circle <= (radius ** 2))

            radius1 = radius - 1
            inside1 = (circle <= (radius1 ** 2))

            mask = mask | inside
            mask1 = mask1 | inside1

        final_mask = mask - mask1

        src_coords = np.argwhere(final_mask > 0)
        dst_coords = np.concatenate((src_coords, np.array([[box_x0, height_block - box_y0 - 1]])), axis=0)
        src_coords = np.concatenate((src_coords, np.array([[box_x1, height_block - box_y1 - 1]])), axis=0)

        old_vals = np.zeros((height_block, width_block))

        for i in range(height_block):
            for j in range(width_block):
                old_vals[i, j] = block.value(i, j)

        tform = skimage.transform.PiecewiseAffineTransform()
        tform.estimate(src_coords, dst_coords)

        warped = skimage.transform.warp(old_vals, tform)

        for i in range(height_block):
            for j in range(width_block):
                if warped[i, j] != 0:
                    block.setValue(i, j, warped[i, j])
                else:
                    block.setValue(i, j, old_vals[i, j])

        offset_row = round((max_y_dem - box_y_max) / pixsize)
        offset_col = round((box_x_min - min_x_dem) / pixsize)

        dem_provider.writeBlock(block, 1, offset_col, offset_row)

        layer_dem.triggerRepaint()
        self.iface.mapCanvas().refresh()
        dem_provider.setEditable(False)

        return









